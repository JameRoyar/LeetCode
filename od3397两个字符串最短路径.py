# 3397: 【DP】2024D-两个字符串间的最短路径
# 内存限制：128 MB
# 时间限制：2.000 S
# 评测方式：文本比较
# 命题人：外部导入
# 提交：279
# 解决：144
# 题目描述
# 给定两个字符串，分别为字符串A与字符串B。
# 例如A字符串为ABCABBA，B字符串为CBABAC，可以得到下图m*n的二维数组，定义原点为(0,0)，终点为(m,n)，水平与垂直的每一条边距离为1，映射成坐标系如下图。
#
# 从原点(0,0)到(0,A)为水平边，距离为1，从(0,A)到(A,C)为垂直边，距离为1；假设两个字符串同一位置的两个字符相同则可以作一个斜边，如(A,C)到(B,B)最短距离为斜边，距离同样为1。出所有的斜边如下图，(0,0)到(B,B)的距离为 1个水平边+ 1个垂直边+ 1个斜边=3。
#
#
# 根据定义可知，原点到终点的最短距离路径如下图红线标记，最短距离为9
#
# 输入
# 空格分割的两个字符串A与字符串B，字符串不为空串，字符格式满足正则规则:[A-Z]，字符串长度<10000
# 输出
# 原点到终点的最短距离`
# 样例输入 复制
# ABC ABC
# 样例输出 复制
# 3
# 提示
#
a, b = input().split()
n, m = len(a), len(b)
dp = [[33333] * n for _ in range(m)]
dp[0][0] = 0
for i in range(n):
    dp[0][i] = i
for j in range(m):
    dp[j][0] = m
for i in range(1, m):
    for j in range(1, n):
        if a[j] == b[i]:
            dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1)
        else:
            dp[i][j] = min(dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1)
print(dp[-1][-1])
