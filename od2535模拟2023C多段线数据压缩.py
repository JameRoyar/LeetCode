# 简化处理，多段线的走向只能是水平、竖直、斜向45度。 上图中的多段线可以用下面的坐标串表示:(2,8),(3,7),(3,6),(3,5),(4,4),(5,3),(6,2),(7,3),(8,4),(7,5)。 但可以发现，这种表示不是最简的，其实只需要存储6个蓝色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是冗余的。 现在，请根据输入的包含有冗余数据的多段线坐标列表，输出其最化的结果。
#
# 输入
# 形如2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
#
# 1、所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号;
#
# 2、行号和列号范围为[0,64)，用例输入保证不会越界，考生不必检查;
#
# 3、输入数据至少包含两个坐标点。
#
# 输出
# 形如2 8 3 7 3 5 6 2 8 4 7 5
#
# 压缩后的最简化坐标列表，和输入数据的格式相同。
#
# 样例输入 复制
# 2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
# 样例输出 复制
# 2 8 3 7 3 5 6 2 8 4 7 5
# 提示
# 输出的坐标相对顺序不能变化。
# 题目：【模拟】2023C-多段线数据压缩
# 分值：100
# 作者：许老师-闭着眼睛学数理化
# 算法：模拟
# 代码看不懂的地方，请直接在群上提问


# 检查是否三点共线的函数
# p1, p2, p3分别为二元组，表示一个点
def check_same_line(p1, p2, p3):
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    return (x2-x1)*(y3-y1) == (x3-x1)*(y2-y1)


# 输入一行数据，包含2*n个坐标
lst = list(map(int, input().split()))
# 将lst转化为n个点，储存在二维列表points中
points = [[lst[i], lst[i+1]] for i in range(0, len(lst), 2)]
# 获得点的个数n
n = len(points)
# 初始化起始端点
start_point = points[0]
# 初始化答案列表，包含起始端点
ans = [start_point]
for i in range(1, n):
    # 检查start_point、points[i-1]和points[i]是否三点共线
    # 若是，说明points[i-1]被忽略，则可以直接跳过
    if check_same_line(start_point, points[i-1], points[i]):
        continue
    # 否则，说明points[i-1]是一个拐点，加入ans中
    # 同时需要修改points[i-1]为新的起始端点start_point
    else:
        ans.append(points[i-1])
        start_point = points[i-1]

# 加入最后一个点的坐标，为终止点
ans.append(points[-1])
# 将ans中的所有二元组输出为1行
print(" ".join(f"{p[0]} {p[1]}" for p in ans))
1