# 黑白图像常采用灰度图的方式存储，即图像的每像素填充一个灰阶值，256阶灰度图是个灰阶值取值范围为0-255的灰阶矩阵，0表示全黑，255表示全白，范围内的其他值表示不同的灰度，比如下面的图像及其对应的灰阶矩阵:

# 但在计算机中实际存储时，会使用压缩算法，其中一种压缩格式和描述如下：10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21
#
# 1. 有数值以空格分隔
#
# 2. 前两个数分别表示矩阵的行数和列数
#
# 3. 从第三个数开始，每两个数一组，每组第一个数是灰阶值，第二个数表示该灰阶值以左到右，从上到下（可理解为将二维数组按行存储在一维矩阵中)的连续像素个数。
#
# 比如题目所述例子，255 34表示有连续34个像素的灰阶值是255。
#
# 如此，图像软件在打开此格式灰度图的时候，就可以根据此算法从压缩数据恢复出原始灰度图矩阵。
#
# 请从输入的压缩数恢复灰度图原始矩阵，并返回指定像素的灰阶值。
#
# 输入
# 输入包括两行，第一行是灰度图压缩数据，第二行表示一个像素位置的行号和列号，如 0 0 表示左上角像素
# 输出
# 一个数字，表示输入数据表示的灰阶矩阵的指定像素的灰阶值
# 样例输入 复制
# 10 10 255 34 0 1 255 8 0 3 255 6 0 5 255 4 0 7 255 2 0 9 255 21
# 3 4
# 样例输出 复制
# 0
# 提示
# 1. 系统保证输入的压缩数据是合法有效的，不会出现数据越界、数值不合法等无法恢复的场景
#
# 2. 系统保证输入的像素坐标是合法的，不会出现不在矩阵中的像素
#
# 3. 矩阵的行和列数范围为: (0, 100]
#
# 4. 灰阶值取值范围为 [0,255]


# 输入第一行数据
lst = list(map(int, input().split()))
# 第一行数据中的前两个位置，为二维矩阵的大小n和m
n, m = lst[0], lst[1]
# 第一行数据中的剩余位置，为灰度压缩数据
nums = lst[2:]
# 注意：如果使用解包方法来读取第一行数据，可以写为
# n, m, *nums = list(map(int, input().split()))
# 和上述三行的作用是一致的

# 输入第二行数据，要求查询的点的二维索引
r, c = map(int, input().split())

# 计算点(r, c)在一维数组中是第几个数
# 注意此处需要+1，表示计数是从1开始的
idx = r*m+c+1

# 获得压缩数据的长度，一共为k//2组数据
k = len(nums)
# 当前已经考虑的灰度值个数，初始化为0
total_num = 0
# 每两个一组遍历数据
for i in range(0, k, 2):
    # 分别获得当前压缩灰度段的值val和个数num
    val, num = nums[i], nums[i+1]
    # 将当前压缩灰度段的个数num计入total_num中
    total_num += num
    # 如果total大于等于idx，说明第idx个数位于当前灰度段中
    # 输入val，并且退出循环
    if total_num >= idx:
        print(val)
        break