# 跳房子，也叫跳飞机，是一种世界性的儿童游戏。
#
# 游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格，然后获得一次选房子的机会，直到所有房子都被选完，房子最多的人获胜。
#
# 跳房子的过程中，如果有踩线等违规行为会结束当前回合，甚至可能倒退几步。
#
# 假设房子的总格数是count，小红每回合可能连续跳的步数都放在数据steps中，请问数组中是否有一种步数的组合，可以让小红三个回合跳到最后一格？
#
# 如果有，请输出索引和最小的步数组合，数据保证索引和最小的步数组合是唯一的。
#
# 注意：数组中的步数可以重复，但数组中的元素不能重复使用。
#
# 输入
# 第一行输入为房子总格数count，它是整数类型int。
#
# 第二行输入为每回合可能连续跳过的步数，它是整数数组类型。
#
# count <= 10000；
# 3 <= steps.length <= 10000；
# -100000 <= steps[i] <= 100000；
#
# 输出
# 返回索引和最小满足要求的步数组合。
#
# 注意：顺序保持steps中的原有顺序。
#
# 样例输入 复制
# 1,5,2,0,2,4
# 9
#
#
# 思路: 排序 + 双指针
# 双指针变种题，没学过双指针的童鞋点这里，简化一下题目，考虑一件事，如果给定一个有序的数组，求找和为x的两个数，则可以用两个指针l, r指向头和尾，若和大于x则r - -即右指针左移，若和小于x则l + +，即左指针右移，当等于x时便是答案
#
# 考虑到一件事，本题要求索引和最小，我们创建一个pair(val, idx)
# 数组，其val存放值，idx存放下标，递增排序（先按val升序排，当两个值val相等时，按idx升序排），这样我们在执行双指针时，遇到和等于x时，我们只需右移右指针即可，因为在值相等的情况下，下标是升序排的，所以左移左指针只会让索引和增加。
#
# 上面的思路是找两个数的算法，时间复杂度是O(n)
# O(n)
# O(n)
#
# 回到本题，我们找三个数，在按上述排序方法排完序后，遍历所有数，对于一个数，可以固定这个数a[i]
#

# input
arr = list(map(int, input().split(',')))
m = int(input())
n = len(arr)
nums = []
for i in range(n):
    nums.append([arr[i], i])

nums.sort()
min_idx = 3 * n
ans = []

for i in range(n - 2):
    val = nums[i][0]
    idx = nums[i][1]
    l = i + 1
    r = n - 1
    while l < r:
        sum_val = val + nums[l][0] + nums[r][0]
        sum_idx = idx + nums[l][1] + nums[r][1]

        if sum_val == m:
            if sum_idx < min_idx:
                min_idx = sum_idx
                ans = [idx, nums[l][1], nums[r][1]]
            r -= 1
    elif sum_val < m:
    l += 1
else:
    r -= 1

ans.sort()
print(f"{arr[ans[0]]},{arr[ans[1]]},{arr[ans[2]]}")
