# 3130: 【贪心】2023C-在规定时间内获得的最大报酬
# 内存限制：128 MB
# 时间限制：2.000 S
# 评测方式：文本比较
# 命题人：外部导入
# 提交：224
# 解决：94
# 题目描述
# 现有N个任务需要在T时间内处理完成，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。
#
# 每个任务都有最晚处理时间限制和报酬，在最晚处理时间点之前处理完成任务才可获得对应的报酬奖励。
#
# 可用于处理任务的时间有限，请问在有限的时间内，可获得的最多报酬?
#
# 1 < N < 100，1 < T < 100
#
# 输入
# 第一行输入两个数T和N，表示N个任务和全部任务的最迟的时间节点T。
#
# 接下来输入N行，每一行输入两个数K和L表示一个任务，K为这个任务的最晚完成时间，L为完成该任务能够获得的报酬。
#
# 输出
# 一个整数，表示能够获取的最大报酬。
# 样例输入 复制
# 3 5
# 1 3
# 2 2
# 3 1
# 3 4
# 4 5
# 样例输出 复制
# 12

# 题目：【贪心】2023C-在规定时间内获得的最大报酬
# 分值：100
# 作者：闭着眼睛学数理化
# 算法：贪心
# 代码看不懂的地方，请直接在群上提问


from collections import defaultdict
# 用一个哈希表储存最晚完成时间为时刻t的任务的报酬
# key为时刻t
# value为由最晚完成时间为t的任务的报酬所构成的列表
dic_task_last_t = defaultdict(list)

# 输入总体最晚完成时间T，任务个数N
T, N = map(int, input().split())
# 循环N次，输入每一行
for _ in range(N):
    # 输入最晚完成时间K，完成该任务获得的报酬L
    K, L = map(int, input().split())
    # 如果K大于T，那么该任务最晚是在时刻T完成
    # 如果K小于T，那么该任务最晚是在时刻K完成
    # 因此键需要取两者之间的较小值
    dic_task_last_t[min(K, T)].append(L)


ans = 0
# 在时刻t时，可以选择的任务的报酬构成的列表，一开始为空列表
cur_task_lst = list()

# 逆向遍历从T到1的所有时刻t
for t in range(T, 0, -1):
    # t时刻可以完成的任务的报酬储存在dic_task_last_t[t]中
    # 将其更新入cur_tack_lst中
    cur_task_lst += dic_task_last_t[t]
    # 对cur_task_lst进行排序
    cur_task_lst.sort()
    # 如果此时cur_task_lst不为空，则选择其中报酬最大的任务去完成
    # 即删除cur_task_lst末尾元素，并将该元素更新入ans中
    if len(cur_task_lst) > 0:
        ans += cur_task_lst.pop()

print(ans)
